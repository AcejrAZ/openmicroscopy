{% python
    def parent_object(name):
        try:
            return model.getObjectByName(parents[name].keys()[0])
        except AttributeError:
            return None

    def is_abstract(name):
        o = model.getObjectByName(name)
        if o is not None and \
           (o.isAbstract or o.isAbstractProprietary):
            return True
        return False

    def is_parent_abstract(name):
        parent = parent_object(name)
        if parent is not None and \
           (parent.isAbstract or parent.isAbstractProprietary):
            return True
        return False

    def sorted_properties(o):
        return sorted(o.properties.values() + o.baseObjectProperties, lambda x, y: cmp(x.name, y.name))
%}\
\
\
<?xml version="1.0" encoding="UTF-8"?>
<!--
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# Copyright 2012 University of Dundee. All rights reserved.
# Use is subject to license terms supplied in LICENSE.txt
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-->

<!--
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
# THIS IS AUTOMATICALLY GENERATED CODE.  DO NOT MODIFY.
# Created by ${fu.user} via xsd-fu on ${fu.date}
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-->

<types>
{% for o in sorted(model.objects.values(), lambda x, y: cmp(x.name, y.name)) %}\
{% if o.name not in fu.METADATA_OBJECT_IGNORE %}\
{% choose %}\
{% when parent_object(o.name) is not None and parent_object(o.name).isAbstractProprietary %}\
    <type id="omero.model.${o.name}" superclass="omero.model.${parent_object(o.name).name}>
{% end %}\
{% when o.isAbstractProprietary or o.isAbstract %}\
    <abstract id="omero.model.${o.name}">
{% end %}\
{% when parent_object(o.name) is None or not parent_object(o.name).isAbstractProprietary %}\
    <type id="omero.model.${o.name}">
{% end %}\
{% end %}\
        <properties>
{% choose %}\
{% when o.isReference %}\
{% for prop in sorted(o.properties.values() + o.baseObjectProperties, lambda x, y: cmp(x.name, y.name)) %}\
            <!--
            // ${prop.minOccurs}:${prop.maxOccurs}
            // Is multi path? ${is_multi_path[o.name]}
            // Ignoring ${prop.name} property of reference ${o.name}
            -->
{% end %}\
{% end %}\
{% otherwise %}\
\
{% for prop in sorted(o.properties.values() + o.baseObjectProperties, lambda x, y: cmp(x.name, y.name)) %}\
{% choose %}\
{% when prop.isReference and prop.maxOccurs > 1%}
            <!--
	        // Reference ${prop.name}
            -->
            <onemany name="${prop.javaInstanceVariableName}" type="omero.model.${prop.javaMethodName}" inverse="${o.name}" ordered="TODO"/>
{% end %}\
{% when prop.isBackReference %}
            <!--
	        // Back reference ${prop.name}
            -->
            <manyone name="${prop.javaInstanceVariableName}" type="omero.model.${prop.javaMethodName}" inverse="${o.name}" ordered="TODO"/>
{% end %}\
{% when prop.maxOccurs == 1 and (not o.isAbstractProprietary or prop.isAttribute or not prop.isComplex()) %}
            <!--
	        // Property
            -->
{% if prop.minOccurs == 1 %}\
            <required name="${prop.javaInstanceVariableName}" type="omero.model.${prop.javaType}"/>
{% end %}\
{% if prop.minOccurs == 0 %}\
            <optional name="${prop.javaInstanceVariableName}" type="omero.model.${prop.javaType}"/>
{% end %}\
{% end %}\
{% when prop.maxOccurs > 1 and not o.isAbstractProprietary %}
            <!--
	        // Property which occurs more than once
            -->
            <onemany name="${prop.javaInstanceVariableName}" type="omero.model.${prop.javaMethodName}" inverse="${o.name}" ordered="TODO"/>
{% end %}\
{% otherwise %}\
            <!--
            // *** WARNING *** Unhandled or skipped property ${prop.name}
            -->
{% end %}\
{% end %}\
{% end %}\
{% end %}\
{% end %}\
        </properties>
    </type>
{% end %}\
{% end %}\
</types>
